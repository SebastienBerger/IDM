/*
 * generated by Xtext
 */
package org.xtext.StateMachine.sm.serializer;

import SimplStateMachine.Assignment;
import SimplStateMachine.BooleanData;
import SimplStateMachine.BooleanVariable;
import SimplStateMachine.CompositeState;
import SimplStateMachine.Event;
import SimplStateMachine.Expression;
import SimplStateMachine.InitialState;
import SimplStateMachine.IntegerData;
import SimplStateMachine.IntegerVariable;
import SimplStateMachine.Operation;
import SimplStateMachine.SimplStateMachinePackage;
import SimplStateMachine.State;
import SimplStateMachine.StateMachine;
import SimplStateMachine.Transition;
import SimplStateMachine.VariableReference;
import com.google.inject.Inject;
import com.google.inject.Provider;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.StateMachine.sm.services.SMGrammarAccess;

@SuppressWarnings("all")
public abstract class AbstractSMSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SMGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == SimplStateMachinePackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case SimplStateMachinePackage.ASSIGNMENT:
				sequence_Assignment(context, (Assignment) semanticObject); 
				return; 
			case SimplStateMachinePackage.BOOLEAN_DATA:
				sequence_BooleanData(context, (BooleanData) semanticObject); 
				return; 
			case SimplStateMachinePackage.BOOLEAN_VARIABLE:
				sequence_BooleanVariable(context, (BooleanVariable) semanticObject); 
				return; 
			case SimplStateMachinePackage.COMPOSITE_STATE:
				sequence_CompositeState_Impl(context, (CompositeState) semanticObject); 
				return; 
			case SimplStateMachinePackage.EVENT:
				sequence_Event(context, (Event) semanticObject); 
				return; 
			case SimplStateMachinePackage.EXPRESSION:
				sequence_Expression(context, (Expression) semanticObject); 
				return; 
			case SimplStateMachinePackage.INITIAL_STATE:
				sequence_InitialState(context, (InitialState) semanticObject); 
				return; 
			case SimplStateMachinePackage.INTEGER_DATA:
				sequence_IntegerData(context, (IntegerData) semanticObject); 
				return; 
			case SimplStateMachinePackage.INTEGER_VARIABLE:
				sequence_IntegerVariable(context, (IntegerVariable) semanticObject); 
				return; 
			case SimplStateMachinePackage.OPERATION:
				sequence_Operation(context, (Operation) semanticObject); 
				return; 
			case SimplStateMachinePackage.STATE:
				sequence_State_Impl(context, (State) semanticObject); 
				return; 
			case SimplStateMachinePackage.STATE_MACHINE:
				sequence_StateMachine(context, (StateMachine) semanticObject); 
				return; 
			case SimplStateMachinePackage.TRANSITION:
				sequence_Transition(context, (Transition) semanticObject); 
				return; 
			case SimplStateMachinePackage.VARIABLE_REFERENCE:
				sequence_VariableReference(context, (VariableReference) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (variable=[Variable|EString] expression=ExpressionElement)
	 */
	protected void sequence_Assignment(EObject context, Assignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     value=EBoolean
	 */
	protected void sequence_BooleanData(EObject context, BooleanData semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, SimplStateMachinePackage.Literals.BOOLEAN_DATA__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimplStateMachinePackage.Literals.BOOLEAN_DATA__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getBooleanDataAccess().getValueEBooleanParserRuleCall_0(), semanticObject.isValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=EString value=BooleanData?)
	 */
	protected void sequence_BooleanVariable(EObject context, BooleanVariable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=EString states+=State+ operation=Operation? initialState=InitialState)
	 */
	protected void sequence_CompositeState_Impl(EObject context, CompositeState semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=STRING
	 */
	protected void sequence_Event(EObject context, Event semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, SimplStateMachinePackage.Literals.EVENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimplStateMachinePackage.Literals.EVENT__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getEventAccess().getNameSTRINGTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (left=ExpressionElement operator=Operator right=ExpressionElement)
	 */
	protected void sequence_Expression(EObject context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     referencedState=[State|EString]
	 */
	protected void sequence_InitialState(EObject context, InitialState semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, SimplStateMachinePackage.Literals.INITIAL_STATE__REFERENCED_STATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimplStateMachinePackage.Literals.INITIAL_STATE__REFERENCED_STATE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getInitialStateAccess().getReferencedStateStateEStringParserRuleCall_0_1(), semanticObject.getReferencedState());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     value=EInt
	 */
	protected void sequence_IntegerData(EObject context, IntegerData semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, SimplStateMachinePackage.Literals.INTEGER_DATA__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimplStateMachinePackage.Literals.INTEGER_DATA__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getIntegerDataAccess().getValueEIntParserRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=EString value=IntegerData?)
	 */
	protected void sequence_IntegerVariable(EObject context, IntegerVariable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((contents+=Assignment contents+=Assignment*)?)
	 */
	protected void sequence_Operation(EObject context, Operation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         variables+=Variable* 
	 *         events+=Event 
	 *         events+=Event* 
	 *         states+=State+ 
	 *         initialState=InitialState 
	 *         transitions+=Transition+
	 *     )
	 */
	protected void sequence_StateMachine(EObject context, StateMachine semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=EString operation=Operation?)
	 */
	protected void sequence_State_Impl(EObject context, State semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (source=[State|EString] target=[State|EString] event=[Event|EString] guard=Expression?)
	 */
	protected void sequence_Transition(EObject context, Transition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     variable=[Variable|EString]
	 */
	protected void sequence_VariableReference(EObject context, VariableReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
}
